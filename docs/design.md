# バイナリ通信プロトコルパーサ設計ドキュメント

## はじめに

本ドキュメントは、ユーザー定義のJSON形式プロトコル仕様に基づきバイナリ通信データを解析するエンジンの設計方針をまとめたものです。可変長フィールドや繰り返しブロック、構造内の動的参照に対応します。

## 設定ファイル
json形式で記述する。

### プロトコル設定

プロトコル仕様は以下の要素で構成されます：

| 要素名 | 必須か | 説明 |
|--------|--------|------|
| `protocolName` | ❌ 任意 | プロトコルの識別名 |
| `structure` | ✅ 必須 | フィールド設定の配列 |

### フィールド設定

プロトコル仕様における各フィールドは、以下の属性を持ちます。

| フィールド名 | 必須か | 説明 |
|--------------|--------|------|
| `type`       | ❌ 任意 | データ型（省略時は`bytes`として扱う） |
| `name`       | ✅ 必須 | フィールドの名称 |
| `id`         | ⛔ 条件付き必須 | 参照用識別子（以下参照） |
| `size`       | ⛔ 条件付き必須 | バイト単位のデータサイズ（`bytes`タイプまたはtype省略時は必須） |
| `content` |  ⛔ 条件付き必須 | 内部フィールド定義の配列。typeがblockの場合は必須。 |
| `repeat` | ❌ 任意 | 指定した個数分、本フィールドを増やす。 |
| `repeatById` | ❌ 任意 | 指定idのフィールドの個数分、本フィールドを増やす。 |

### フィールドの詳細

#### データ型定義(`type`)

##### `type`一覧
記載がない場合、デフォルトはbyteとします。

| 型名 | 説明 | バイト数 | 備考 |
|------|------|----------|------|
| uint8 | 符号なし8ビット整数 | 1 | 自動サイズ設定 |
| uint16 | 符号なし16ビット整数 | 2 | 自動サイズ設定 |
| bytes | バイト列 | size指定 | sizeパラメータ必須 |
| block | 複合構造体 | - | content配列で内部構造を定義 |

##### ブロックタイプの概要

blockタイプは複数のフィールドをグループ化する複合構造体を定義します。以下の特徴があります：

- 内部構造を`content`配列で定義
- 任意の深さのネスト構造が可能
- 繰り返し設定との組み合わせが可能


#### `size`

typeがbytesの場合、sizeでバイトサイズを指定します。

#### `name`

フィールドの名前です。GUI上で表示することを想定しています。

#### `repeat`

複数個フィールドが連続する場合に、repeatを使えばまとめて記載できます。フィールドだけでなく、blockを繰り返すことも可能です。

#### `repeatById`と`id`

`id`フィールドは、フィールドを一意に定めて参照するためのフィールドです。
repeatByIdで、repeat数を指定するために現時点では使います。

### 具体例

#### 基本的なブロック例

```json
{
  "protocolName": "ブロック構造例",
  "structure": [
    {
      "name": "sample",
      "size": 1
    },
    {
      "type": "block",
      "name": "blockName",
      "content": [
        {
          "size": 1,
          "name": "1field"
        },
        {
          "size": 2,
          "name": "2fields"
        }
      ]
    }
  ]
}
```

このブロックは以下のようにパースされます：
```
sample : 00
blockName
  1field : 01
  2fields : 0102
```

#### 繰り返し構造

フィールドやブロックの繰り返しには2つの方式があります：

###### 1. 固定回数繰り返し

```json
{
  "name": "センサー値",
  "size": 1,
  "repeat": 3
}
```

パース結果例：
```
センサー値(1) : 01
センサー値(2) : 02
センサー値(3) : 03
```

###### 2. ID参照による可変回数繰り返し

```json
{
  "id": "count",
  "name": "センサー数",
  "type": "uint8"
},
{
  "name": "センサー値",
  "size": 2,
  "repeatById": "count"
}
```

バイナリ値が`02 03 04 05 06`の場合のパース結果例：
```
センサー数 : 02
センサー値(1) : 0304
センサー値(2) : 0506
```

###### ブロックの繰り返しパターン

1. 固定回数繰り返し
```json
{
  "type": "block",
  "name": "センサーブロック",
  "repeat": 3,
  "content": [
    {
      "name": "センサーID",
      "type": "uint8"
    },
    {
      "name": "値",
      "type": "uint16"
    }
  ]
}
```

2. フィールド参照による繰り返し
```json
{
  "type": "block",
  "name": "センサーブロック",
  "repeatById": "count",
  "content": [
    {
      "name": "センサーID",
      "type": "uint8"
    },
    {
      "name": "値",
      "type": "uint16"
    }
  ]
}
```

## パース結果の構造

### 階層構造

パース結果は以下の要素からなるツリー構造で表現されます：

- ParsedData: パース結果のルート
  - ProtocolName: プロトコル名
  - RootFields: トップレベルのフィールド配列
    - Field: 各フィールドの情報
      - Id: 参照用ID
      - Name: フィールド名
      - HexStr: 16進数表現の値
      - Children: 子フィールド配列（ブロックの場合）

### フィールド値の表現

- 単一フィールド: バイト配列を16進数文字列に変換
  - 例：`01` → `"01"`、`01 02` → `"0102"`
- ブロックフィールド: 子フィールドの配列として保持
- 繰り返しフィールド: 名前に連番を付加（例：`name(1)`, `name(2)`）
- 値が存在しない場合は`"--"`を表示

### 値の参照と変換

- `ParseToInt()`: uint8/uint16値を整数に変換
- `HexStr`: バイト配列を16進文字列に変換
- ブロック値の参照は子フィールドのリストを通じて行う

## 設計方針まとめ

- フィールド名称は `name` 属性で指定
- `type`属性は省略可能（デフォルトは`bytes`）
- `id` は参照が必要な場合のみ利用
- データ型に応じて適切なサイズを自動設定
- JSON仕様は手書きに優しい軽量な設計とする
- ブロック構造により複雑なデータ構造を表現可能
- 固定長・可変長の繰り返し構造をサポート

### 主要な変更履歴

- labelをnameに変更（表示用ラベルの概念を統合）
- プロトコル名による識別機能を追加
- データ型ごとの固定サイズを明確化
- ブロック型によるネスト構造の詳細化
- 繰り返し構造のパターンを整理
- パース結果の構造を体系化
- 具体的な使用例とパース結果例を追加